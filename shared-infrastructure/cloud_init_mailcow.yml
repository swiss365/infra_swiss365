#cloud-config
# Central Mailcow Server - Multi-Domain Mail with Status Server
# IMPROVED: Docker-pull retry, admin login test, UFW activation

package_update: true
package_upgrade: true

packages:
  - docker.io
  - docker-compose
  - git
  - curl
  - jq
  - python3

write_files:
  - path: /opt/swiss365/status-server.py
    permissions: '0755'
    content: |
      #!/usr/bin/env python3
      """Swiss365 Unified Status Server for Mailcow"""
      import http.server
      import json
      import subprocess
      import os
      import hashlib
      import hmac
      import time
      from urllib.parse import urlparse, parse_qs

      STATUS_PORT = 8081
      AGENT_PORT = 9365
      AGENT_SECRET = "${agent_secret}"

      def run_cmd(cmd, timeout=30):
          try:
              result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=timeout)
              return result.stdout.strip(), result.returncode
          except Exception as e:
              return str(e), 1

      def get_docker_status():
          containers = []
          output, _ = run_cmd("docker ps -a --format '{{.Names}}|{{.Status}}|{{.Image}}'")
          for line in output.split('\n'):
              if '|' in line:
                  parts = line.split('|')
                  containers.append({
                      'name': parts[0],
                      'status': parts[1],
                      'image': parts[2] if len(parts) > 2 else ''
                  })
          return containers

      def get_system_metrics():
          cpu, _ = run_cmd("top -bn1 | grep 'Cpu(s)' | awk '{print $2}'")
          mem, _ = run_cmd("free -m | awk 'NR==2{printf \"%.1f\", $3*100/$2}'")
          disk, _ = run_cmd("df -h / | awk 'NR==2{print $5}' | tr -d '%'")
          return {'cpu': cpu, 'memory': mem, 'disk': disk}

      def get_mailcow_health():
          # Check Mailcow API
          api_status, _ = run_cmd("curl -s -o /dev/null -w '%%{http_code}' http://localhost/api/v1/get/status/containers 2>/dev/null || echo '0'")
          # Check critical services
          postfix, _ = run_cmd("docker ps -q -f name=postfix-mailcow -f status=running")
          dovecot, _ = run_cmd("docker ps -q -f name=dovecot-mailcow -f status=running")
          nginx, _ = run_cmd("docker ps -q -f name=nginx-mailcow -f status=running")
          return {
              'api_responding': api_status == '200',
              'postfix_running': bool(postfix),
              'dovecot_running': bool(dovecot),
              'nginx_running': bool(nginx)
          }

      def get_install_logs():
          logs = []
          log_file = '/var/log/swiss365/install.log'
          if os.path.exists(log_file):
              with open(log_file, 'r') as f:
                  logs = f.readlines()[-100:]
          return [l.strip() for l in logs]

      class StatusHandler(http.server.BaseHTTPRequestHandler):
          def log_message(self, format, *args):
              pass

          def send_json(self, data, status=200):
              self.send_response(status)
              self.send_header('Content-Type', 'application/json')
              self.send_header('Access-Control-Allow-Origin', '*')
              self.end_headers()
              self.wfile.write(json.dumps(data).encode())

          def do_GET(self):
              path = urlparse(self.path).path
              
              if path == '/health':
                  self.send_json({'status': 'ok', 'service': 'mailcow'})
              elif path == '/status':
                  health = get_mailcow_health()
                  self.send_json({
                      'service': 'mailcow',
                      'timestamp': time.time(),
                      'healthy': all(health.values()),
                      'health': health,
                      'docker': get_docker_status(),
                      'metrics': get_system_metrics()
                  })
              elif path == '/docker':
                  self.send_json({'containers': get_docker_status()})
              elif path == '/metrics':
                  self.send_json(get_system_metrics())
              elif path == '/logs':
                  self.send_json({'logs': get_install_logs()})
              else:
                  self.send_json({'error': 'Not found'}, 404)

      class AgentHandler(http.server.BaseHTTPRequestHandler):
          def log_message(self, format, *args):
              pass

          def verify_signature(self):
              sig = self.headers.get('X-Signature', '')
              content_length = int(self.headers.get('Content-Length', 0))
              body = self.rfile.read(content_length).decode() if content_length > 0 else ''
              expected = hmac.new(AGENT_SECRET.encode(), body.encode(), hashlib.sha256).hexdigest()
              return hmac.compare_digest(sig, expected), body

          def send_json(self, data, status=200):
              self.send_response(status)
              self.send_header('Content-Type', 'application/json')
              self.send_header('Access-Control-Allow-Origin', '*')
              self.end_headers()
              self.wfile.write(json.dumps(data).encode())

          def do_OPTIONS(self):
              self.send_response(200)
              self.send_header('Access-Control-Allow-Origin', '*')
              self.send_header('Access-Control-Allow-Methods', 'POST, OPTIONS')
              self.send_header('Access-Control-Allow-Headers', 'Content-Type, X-Signature')
              self.end_headers()

          def do_POST(self):
              valid, body = self.verify_signature()
              if not valid:
                  self.send_json({'error': 'Invalid signature'}, 401)
                  return

              path = urlparse(self.path).path
              params = json.loads(body) if body else {}

              if path == '/restart':
                  service = params.get('service', 'all')
                  if service == 'all':
                      output, code = run_cmd('cd /opt/mailcow && docker-compose restart')
                  else:
                      output, code = run_cmd(f'docker restart {service}')
                  self.send_json({'success': code == 0, 'output': output})
              elif path == '/logs':
                  service = params.get('service', '')
                  lines = params.get('lines', 100)
                  if service:
                      output, _ = run_cmd(f'docker logs --tail {lines} {service} 2>&1')
                  else:
                      output, _ = run_cmd(f'tail -n {lines} /var/log/swiss365/install.log')
                  self.send_json({'logs': output})
              elif path == '/execute':
                  cmd = params.get('command', '')
                  if cmd in ['docker-compose up -d', 'docker-compose down', 'docker-compose restart']:
                      output, code = run_cmd(f'cd /opt/mailcow && {cmd}')
                      self.send_json({'success': code == 0, 'output': output})
                  else:
                      self.send_json({'error': 'Command not allowed'}, 403)
              else:
                  self.send_json({'error': 'Not found'}, 404)

      if __name__ == '__main__':
          import threading
          
          # Start status server on 8081
          status_server = http.server.HTTPServer(('0.0.0.0', STATUS_PORT), StatusHandler)
          status_thread = threading.Thread(target=status_server.serve_forever)
          status_thread.daemon = True
          status_thread.start()
          print(f"Status server running on port {STATUS_PORT}")
          
          # Start agent server on 9365
          agent_server = http.server.HTTPServer(('0.0.0.0', AGENT_PORT), AgentHandler)
          print(f"Agent server running on port {AGENT_PORT}")
          agent_server.serve_forever()

  - path: /etc/systemd/system/swiss365-status.service
    permissions: '0644'
    content: |
      [Unit]
      Description=Swiss365 Status Server
      After=network.target docker.service

      [Service]
      Type=simple
      ExecStart=/usr/bin/python3 /opt/swiss365/status-server.py
      Restart=always
      RestartSec=5
      StandardOutput=append:/var/log/swiss365/status-server.log
      StandardError=append:/var/log/swiss365/status-server.log

      [Install]
      WantedBy=multi-user.target

  - path: /usr/local/bin/swiss365-callback
    permissions: '0755'
    content: |
      #!/bin/bash
      STATUS=$1
      STEP=$2
      PROGRESS=$3
      DETAILS=$4
      
      CALLBACK_URL="${callback_url}"
      WORKSPACE_ID="${workspace_id}"
      SERVER_TYPE="mailcow"
      
      mkdir -p /var/log/swiss365
      echo "$(date '+%Y-%m-%d %H:%M:%S') [$STATUS] $STEP ($PROGRESS%) - $DETAILS" >> /var/log/swiss365/install.log
      
      if [ -n "$CALLBACK_URL" ]; then
        curl -s -X POST "$CALLBACK_URL" \
          -H "Content-Type: application/json" \
          -d "{\"workspace_id\":\"$WORKSPACE_ID\",\"server_type\":\"$SERVER_TYPE\",\"status\":\"$STATUS\",\"current_step\":\"$STEP\",\"progress\":$PROGRESS,\"details\":\"$DETAILS\",\"server_ip\":\"$(hostname -I | awk '{print $1}')\"}" \
          || true
      fi

  # Docker pull with retry logic
  - path: /usr/local/bin/docker-pull-retry
    permissions: '0755'
    content: |
      #!/bin/bash
      # Docker pull with exponential backoff retry
      IMAGE=$1
      MAX_RETRIES=5
      RETRY=0
      DELAY=5
      
      while [ $RETRY -lt $MAX_RETRIES ]; do
        echo "Pulling $IMAGE (attempt $((RETRY+1))/$MAX_RETRIES)..."
        if docker pull "$IMAGE"; then
          echo "Successfully pulled $IMAGE"
          exit 0
        fi
        RETRY=$((RETRY+1))
        if [ $RETRY -lt $MAX_RETRIES ]; then
          echo "Failed to pull $IMAGE, retrying in ${DELAY}s..."
          sleep $DELAY
          DELAY=$((DELAY*2))
        fi
      done
      
      echo "ERROR: Failed to pull $IMAGE after $MAX_RETRIES attempts"
      exit 1

  # Admin login test script
  - path: /usr/local/bin/test-mailcow-login
    permissions: '0755'
    content: |
      #!/bin/bash
      # Test Mailcow admin login via API
      API_KEY="${api_key}"
      MAX_RETRIES=30
      RETRY=0
      
      echo "Testing Mailcow admin API access..."
      
      while [ $RETRY -lt $MAX_RETRIES ]; do
        # Test API with the configured API key
        RESPONSE=$(curl -s -X GET "http://localhost/api/v1/get/status/version" \
          -H "X-API-Key: $API_KEY" \
          -H "Content-Type: application/json" \
          -w "\n%%{http_code}" 2>/dev/null)
        
        HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
        BODY=$(echo "$RESPONSE" | sed '$d')
        
        if [ "$HTTP_CODE" = "200" ]; then
          echo "Mailcow API login successful!"
          echo "Response: $BODY"
          exit 0
        fi
        
        # Alternative: Test web UI login (less reliable but fallback)
        WEB_CODE=$(curl -s -o /dev/null -w "%%{http_code}" http://localhost/ 2>/dev/null)
        if [ "$WEB_CODE" = "200" ] || [ "$WEB_CODE" = "302" ]; then
          echo "Mailcow web interface responding (HTTP $WEB_CODE)"
          # If API not working but web is, might be OK
          if [ $RETRY -gt 10 ]; then
            echo "Web interface works, API may need more time"
            exit 0
          fi
        fi
        
        RETRY=$((RETRY+1))
        echo "Waiting for Mailcow API... ($RETRY/$MAX_RETRIES) HTTP: $HTTP_CODE"
        sleep 10
      done
      
      echo "ERROR: Mailcow API login failed after $MAX_RETRIES attempts"
      exit 1

runcmd:
  - mkdir -p /opt/swiss365
  - mkdir -p /var/log/swiss365
  - touch /var/log/swiss365/install.log
  - swiss365-callback "installing" "init" 5 "Starting Mailcow installation"
  
  - systemctl enable docker
  - systemctl start docker
  - swiss365-callback "installing" "docker" 15 "Docker started"
  
  # Clone Mailcow
  - swiss365-callback "installing" "clone" 20 "Cloning Mailcow repository"
  - cd /opt && git clone https://github.com/mailcow/mailcow-dockerized.git mailcow
  - cd /opt/mailcow
  
  # Generate config
  - swiss365-callback "installing" "config" 30 "Generating Mailcow configuration"
  - |
    cat > /opt/mailcow/mailcow.conf << 'EOF'
    MAILCOW_HOSTNAME=${mailcow_domain}
    DBNAME=mailcow
    DBUSER=mailcow
    DBPASS=${db_password}
    DBROOT=${db_password}
    HTTP_PORT=80
    HTTPS_PORT=443
    HTTP_BIND=0.0.0.0
    HTTPS_BIND=0.0.0.0
    SMTP_PORT=25
    SMTPS_PORT=465
    SUBMISSION_PORT=587
    IMAP_PORT=143
    IMAPS_PORT=993
    POP_PORT=110
    POPS_PORT=995
    SIEVE_PORT=4190
    DOVEADM_PORT=127.0.0.1:19991
    SQL_PORT=127.0.0.1:13306
    SOLR_PORT=127.0.0.1:18983
    REDIS_PORT=127.0.0.1:7654
    TZ=Europe/Zurich
    COMPOSE_PROJECT_NAME=mailcow
    SKIP_LETS_ENCRYPT=y
    SKIP_CLAMD=n
    SKIP_SOGO=n
    ALLOW_ADMIN_EMAIL_LOGIN=y
    ADDITIONAL_SAN=
    API_KEY=${api_key}
    API_KEY_READ_ONLY=
    API_ALLOW_FROM=0.0.0.0/0
    MAILDIR_GC_TIME=7200
    ACL_ANYONE=disallow
    MAILDIR_SUB=Maildir
    SOGO_EXPIRE_SESSION=480
    LOG_LINES=9999
    WATCHDOG_NOTIFY_EMAIL=
    WATCHDOG_NOTIFY_BAN=y
    WATCHDOG_EXTERNAL_CHECKS=n
    WATCHDOG_MYSQL_REPLICATION_CHECKS=n
    IPV4_NETWORK=172.22.1
    IPV6_NETWORK=fd4d:6169:6c63:6f77::/64
    SNAT_TO_SOURCE=n
    SNAT6_TO_SOURCE=n
    EOF
  
  # Pull with retry logic
  - swiss365-callback "installing" "pull" 40 "Pulling Docker images (with retry)"
  - |
    cd /opt/mailcow
    for i in 1 2 3 4 5; do
      echo "Docker-compose pull attempt $i..."
      if docker-compose pull; then
        echo "Pull successful on attempt $i"
        break
      fi
      echo "Pull failed, waiting before retry..."
      sleep $((i * 10))
      if [ $i -eq 5 ]; then
        swiss365-callback "error" "pull" 45 "Failed to pull Docker images after 5 attempts"
        exit 1
      fi
    done
  
  # Sequential container startup for stability
  - swiss365-callback "installing" "start" 50 "Starting MySQL first"
  - cd /opt/mailcow && docker-compose up -d mysql-mailcow
  
  # Wait for MySQL
  - |
    echo "Waiting for MySQL..."
    for i in {1..60}; do
      if docker exec $(docker ps -qf "name=mysql-mailcow") mysqladmin ping -h localhost --silent 2>/dev/null; then
        echo "MySQL is ready"
        break
      fi
      echo "Waiting for MySQL... ($i/60)"
      sleep 5
    done
  - swiss365-callback "installing" "database" 55 "MySQL ready"
  
  # Start remaining services
  - swiss365-callback "installing" "start" 60 "Starting remaining Mailcow containers"
  - cd /opt/mailcow && docker-compose up -d
  
  # Real health check - wait for Mailcow to respond
  - swiss365-callback "installing" "healthcheck" 70 "Waiting for services to be ready"
  - |
    for i in {1..60}; do
      HTTP_CODE=$(curl -s -o /dev/null -w "%%{http_code}" http://localhost/ 2>/dev/null || echo "000")
      if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "302" ]; then
        swiss365-callback "installing" "healthcheck" 80 "Mailcow web interface responding"
        break
      fi
      echo "Waiting for Mailcow... ($i/60) HTTP: $HTTP_CODE"
      sleep 10
    done
  
  # Set admin password via API
  - swiss365-callback "installing" "admin" 85 "Setting admin password"
  - |
    docker exec -i $(docker ps -qf "name=mailcow-php-fpm") php -r "
    \$pdo = new PDO('mysql:host=mysql;dbname=mailcow', 'mailcow', '${db_password}');
    \$hash = password_hash('${admin_password}', PASSWORD_BCRYPT);
    \$pdo->exec(\"UPDATE admin SET password='\$hash' WHERE username='admin'\");
    " || true
  
  # Test admin login
  - swiss365-callback "installing" "login-test" 88 "Testing admin API access"
  - |
    LOGIN_OK=false
    for i in {1..20}; do
      # Test API access
      API_RESPONSE=$(curl -s -o /dev/null -w "%%{http_code}" \
        "http://localhost/api/v1/get/status/version" \
        -H "X-API-Key: ${api_key}" 2>/dev/null)
      
      if [ "$API_RESPONSE" = "200" ]; then
        echo "Mailcow API verified successfully!"
        LOGIN_OK=true
        break
      fi
      echo "API test attempt $i - HTTP $API_RESPONSE"
      sleep 5
    done
    
    if [ "$LOGIN_OK" = "false" ]; then
      echo "WARNING: API verification failed, but continuing..."
    fi
  
  # Start status server
  - swiss365-callback "installing" "status-server" 90 "Starting status server"
  - systemctl daemon-reload
  - systemctl enable swiss365-status
  - systemctl start swiss365-status
  
  # Configure and ACTIVATE firewall
  - ufw allow 22/tcp
  - ufw allow 80/tcp
  - ufw allow 443/tcp
  - ufw allow 25/tcp
  - ufw allow 465/tcp
  - ufw allow 587/tcp
  - ufw allow 143/tcp
  - ufw allow 993/tcp
  - ufw allow 110/tcp
  - ufw allow 995/tcp
  - ufw allow 4190/tcp
  - ufw allow 8081/tcp
  - ufw allow 9365/tcp
  - ufw --force enable
  
  # Final health verification with login test
  - |
    API_OK=$(curl -s -o /dev/null -w "%%{http_code}" \
      "http://localhost/api/v1/get/status/version" \
      -H "X-API-Key: ${api_key}" 2>/dev/null)
    WEB_OK=$(curl -s -o /dev/null -w "%%{http_code}" http://localhost/ 2>/dev/null)
    
    if [ "$API_OK" = "200" ]; then
      swiss365-callback "ready" "complete" 100 "Mailcow installation complete - API verified"
    elif [ "$WEB_OK" = "200" ] || [ "$WEB_OK" = "302" ]; then
      swiss365-callback "ready" "complete" 100 "Mailcow installation complete - Web UI verified"
    else
      swiss365-callback "error" "healthcheck" 95 "Mailcow not responding (API: $API_OK, Web: $WEB_OK)"
    fi
